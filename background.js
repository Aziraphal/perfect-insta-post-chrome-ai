// =============================================================================
// PERFECT INSTA POST - SERVICE WORKER (BACKGROUND.JS)
// Gestion de l'authentification Google OAuth avec chrome.identity
// =============================================================================

const CONFIG = {
    backend: {
        baseUrl: 'https://perfect-insta-extension-production.up.railway.app',
        endpoints: {
            auth: '/auth/google',
            userMe: '/api/user/me',
            generatePost: '/api/generate-post'
        }
    }
};

// √âtat global du service worker
let authState = {
    isAuthenticated: false,
    jwtToken: null,
    user: null
};

// =============================================================================
// INITIALISATION DU SERVICE WORKER
// =============================================================================

// Charger l'√©tat d'authentification au d√©marrage du service worker
chrome.runtime.onStartup.addListener(async () => {
    console.log('üöÄ Perfect Insta Service Worker - Startup');
    await loadAuthState();
});

chrome.runtime.onInstalled.addListener(async () => {
    console.log('üöÄ Perfect Insta Service Worker - Installed');
    await loadAuthState();
});

// Charger l'√©tat d'authentification depuis chrome.storage
async function loadAuthState() {
    try {
        const stored = await chrome.storage.local.get(['jwtToken', 'user']);
        if (stored.jwtToken && stored.user) {
            authState.jwtToken = stored.jwtToken;
            authState.user = stored.user;
            authState.isAuthenticated = true;
            console.log('‚úÖ Auth state charg√©:', stored.user.email);

            // Valider le token avec le backend
            await validateToken();
        } else {
            console.log('üîç Aucun √©tat d\'auth trouv√©');
            authState.isAuthenticated = false;
        }
    } catch (error) {
        console.error('‚ùå Erreur chargement auth state:', error);
        authState.isAuthenticated = false;
    }
}

// =============================================================================
// GESTION DES MESSAGES DEPUIS LE POPUP
// =============================================================================

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('üì® Message re√ßu:', message.type);

    switch (message.type) {
        case 'LOGIN':
            handleLogin(sendResponse);
            return true; // R√©ponse asynchrone

        case 'GET_AUTH':
            sendResponse({
                isAuthenticated: authState.isAuthenticated,
                token: authState.jwtToken,
                user: authState.user
            });
            return false;

        case 'LOGOUT':
            handleLogout(sendResponse);
            return true; // R√©ponse asynchrone

        case 'VALIDATE_TOKEN':
            validateToken().then(() => {
                sendResponse({
                    isAuthenticated: authState.isAuthenticated,
                    user: authState.user
                });
            });
            return true; // R√©ponse asynchrone

        default:
            console.warn('‚ö†Ô∏è Type de message non reconnu:', message.type);
            sendResponse({ success: false, error: 'Type de message non reconnu' });
            return false;
    }
});

// =============================================================================
// AUTHENTIFICATION GOOGLE OAUTH
// =============================================================================

async function handleLogin(sendResponse) {
    try {
        console.log('üîê D√©marrage du flow OAuth simple...');

        // Ouvrir un onglet normal vers la page de connexion
        const authUrl = `${CONFIG.backend.baseUrl}/auth/extension`;
        console.log('üåê Auth URL:', authUrl);

        chrome.tabs.create({ url: authUrl }, (tab) => {
            console.log('üîó Onglet OAuth ouvert:', tab.id);

            // √âcouter les changements d'URL de cet onglet
            const updateListener = (tabId, changeInfo, updatedTab) => {
                if (tabId === tab.id && changeInfo.url) {
                    console.log('üîÑ URL chang√©e:', changeInfo.url);

                    // V√©rifier si on a une r√©ponse de succ√®s (callback ou success)
                    if ((changeInfo.url.includes('/auth/success') && changeInfo.url.includes('success=true')) ||
                        (changeInfo.url.includes('/auth/google/callback') && changeInfo.url.includes('code='))) {
                        try {
                            console.log('üéØ URL de succ√®s d√©tect√©e:', changeInfo.url);
                            const url = new URL(changeInfo.url);

                            // Si c'est /auth/success, extraire directement token et user
                            if (changeInfo.url.includes('/auth/success')) {
                                const token = url.searchParams.get('token');
                                const userStr = url.searchParams.get('user');

                                console.log('üîë Token extrait:', token ? 'pr√©sent' : 'manquant');
                                console.log('üë§ User extrait:', userStr ? 'pr√©sent' : 'manquant');

                                if (token && userStr) {
                                    const user = JSON.parse(decodeURIComponent(userStr));
                                    console.log('‚úÖ Donn√©es utilisateur pars√©es:', user.email);

                                    // Sauvegarder l'√©tat d'auth
                                    saveAuthState(token, user).then(() => {
                                        console.log('üíæ Auth state sauvegard√©');
                                        sendResponse({
                                            success: true,
                                            token: token,
                                            user: user
                                        });

                                        // Attendre un peu avant de fermer l'onglet
                                        setTimeout(() => {
                                            chrome.tabs.remove(tab.id);
                                            chrome.tabs.onUpdated.removeListener(updateListener);
                                        }, 1000);
                                    });
                                } else {
                                    console.error('‚ùå Token ou user manquant dans l\'URL');
                                    sendResponse({
                                        success: false,
                                        error: 'Token ou donn√©es utilisateur manquants'
                                    });
                                }
                            }
                            // Si c'est /auth/google/callback, attendre un peu la redirection
                            else if (changeInfo.url.includes('/auth/google/callback')) {
                                console.log('‚è≥ Callback d√©tect√©, attente de la redirection...');
                                // Attendre 3 secondes que la page se redirige vers /auth/success
                                setTimeout(() => {
                                    chrome.tabs.get(tab.id, (currentTab) => {
                                        if (chrome.runtime.lastError) {
                                            console.log('‚ö†Ô∏è Onglet ferm√© pendant l\'attente');
                                            return;
                                        }

                                        console.log('üîç URL apr√®s attente:', currentTab.url);

                                        // Si toujours sur callback, forcer une v√©rification manuelle
                                        if (currentTab.url.includes('/auth/google/callback')) {
                                            console.log('‚ùå Pas de redirection, √©chec de l\'authentification');
                                            sendResponse({
                                                success: false,
                                                error: 'Redirection vers la page de succ√®s √©chou√©e'
                                            });
                                            chrome.tabs.remove(tab.id);
                                            chrome.tabs.onUpdated.removeListener(updateListener);
                                        }
                                    });
                                }, 3000);
                            }
                        } catch (parseError) {
                            console.error('‚ùå Erreur parsing OAuth:', parseError);
                            sendResponse({
                                success: false,
                                error: 'Erreur parsing: ' + parseError.message
                            });
                            chrome.tabs.remove(tab.id);
                            chrome.tabs.onUpdated.removeListener(updateListener);
                        }
                    }

                    // V√©rifier si on a une erreur
                    if (changeInfo.url.includes('error=')) {
                        const url = new URL(changeInfo.url);
                        const error = url.searchParams.get('error') || 'Erreur OAuth inconnue';

                        console.error('‚ùå Erreur OAuth:', error);
                        sendResponse({
                            success: false,
                            error: error
                        });
                        chrome.tabs.remove(tab.id);
                        chrome.tabs.onUpdated.removeListener(updateListener);
                    }
                }
            };

            chrome.tabs.onUpdated.addListener(updateListener);

            // Timeout apr√®s 5 minutes
            setTimeout(() => {
                chrome.tabs.onUpdated.removeListener(updateListener);
                sendResponse({
                    success: false,
                    error: 'Timeout - connexion trop longue'
                });
            }, 5 * 60 * 1000);
        });

    } catch (error) {
        console.error('‚ùå Erreur g√©n√©rale lors du login:', error);
        sendResponse({
            success: false,
            error: 'Erreur g√©n√©rale: ' + error.message
        });
    }
}

// Sauvegarder l'√©tat d'authentification
async function saveAuthState(token, user) {
    try {
        // Sauvegarder en local
        await chrome.storage.local.set({
            jwtToken: token,
            user: user
        });

        // Mettre √† jour l'√©tat du service worker
        authState.jwtToken = token;
        authState.user = user;
        authState.isAuthenticated = true;

        console.log('üíæ √âtat d\'auth sauvegard√© pour:', user.email);
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde auth state:', error);
        throw error;
    }
}

// =============================================================================
// D√âCONNEXION
// =============================================================================

async function handleLogout(sendResponse) {
    try {
        console.log('üö™ D√©connexion en cours...');

        // Supprimer de chrome.storage
        await chrome.storage.local.remove(['jwtToken', 'user']);

        // Reset de l'√©tat du service worker
        authState.jwtToken = null;
        authState.user = null;
        authState.isAuthenticated = false;

        console.log('‚úÖ D√©connexion r√©ussie');
        sendResponse({ success: true });

    } catch (error) {
        console.error('‚ùå Erreur lors de la d√©connexion:', error);
        sendResponse({
            success: false,
            error: error.message
        });
    }
}

// =============================================================================
// VALIDATION TOKEN
// =============================================================================

async function validateToken() {
    if (!authState.jwtToken) {
        authState.isAuthenticated = false;
        return;
    }

    try {
        console.log('üîç Validation du token...');

        const response = await fetch(`${CONFIG.backend.baseUrl}${CONFIG.backend.endpoints.userMe}`, {
            headers: {
                'Authorization': `Bearer ${authState.jwtToken}`,
                'Content-Type': 'application/json'
            }
        });

        if (response.ok) {
            const data = await response.json();
            authState.user = data.user;
            authState.isAuthenticated = true;
            console.log('‚úÖ Token valide, utilisateur:', data.user.email);

            // Mettre √† jour le storage avec les nouvelles donn√©es
            await chrome.storage.local.set({ user: data.user });
        } else {
            console.warn('‚ö†Ô∏è Token invalide, d√©connexion...');
            await handleLogout(() => {});
        }
    } catch (error) {
        console.error('‚ùå Erreur validation token:', error);
        // Ne pas d√©connecter automatiquement en cas d'erreur r√©seau
    }
}

// =============================================================================
// VALIDATION P√âRIODIQUE DU TOKEN
// =============================================================================

// Valider le token toutes les 30 minutes
setInterval(async () => {
    if (authState.isAuthenticated) {
        console.log('üîÑ Validation p√©riodique du token...');
        await validateToken();
    }
}, 30 * 60 * 1000); // 30 minutes

console.log('üéØ Perfect Insta Service Worker initialis√©');